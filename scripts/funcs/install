#!/usr/bin/env bash

set -euo pipefail

# Supported target formats:
#   - "standard" (default): x86_64→amd64, aarch64|arm64→arm64, ppc64le→ppc64le, s390x→s390x
#   - "jq": same as standard but ppc64le→ppc64el (jq's naming convention)
#
detect_architecture() {
    local target_format="${1:-standard}"
    local arch
    arch=$(uname -m)
      # Use standard mapping for most tools, with special case for jq's ppc64le naming
      local ppc64_suffix="ppc64le"
      if [[ "${target_format}" == "jq" ]]; then
          ppc64_suffix="ppc64el"  # jq uses ppc64el instead of ppc64le
      fi

      case "${arch}" in
          x86_64)
              echo "amd64"
              ;;
          aarch64|arm64)
              echo "arm64"
              ;;
          ppc64le)
              echo "${ppc64_suffix}"
              ;;
          s390x)
              echo "s390x"
              ;;
          *)
              echo "Error: Unsupported architecture: ${arch}" >&2
              echo "Supported architectures: x86_64 (amd64), aarch64 (arm64), ppc64le, s390x" >&2
              return 1
              ;;
      esac
}

# Curl wrapper with jitter and consistent retry params for CI downloads.
# Adds 0-30s random jitter to prevent thundering herd when CI retries trigger simultaneously.
# Time range: 0-630s (0-30s jitter + up to 600s curl timeout).
# Set SKIP_DOWNLOAD_JITTER=1 to disable jitter (useful for local development).
# Usage: curl_with_retry [curl options...] URL
curl_with_retry() {
    if [[ "${SKIP_DOWNLOAD_JITTER:-}" != "1" ]]; then
        local jitter=$((RANDOM % 31))
        echo "Adding ${jitter}s jitter to spread out concurrent downloads..."
        sleep "${jitter}"
    fi
    curl --retry 5 --retry-delay 10 --retry-all-errors --fail-with-body --show-error --max-time 600 "$@"
}

# Downloads a binary <bin> from <url> and moves it into <dir> directory.
# Example usage: download_and_install_binary ${workdir}/bin jq "https://..."
download_and_install_binary() {
  dir=$1
  bin=$2
  url=$3

  mkdir -p "${dir}"
  echo "Downloading ${url}"
  curl_with_retry -L "${url}" -o "${bin}"
  chmod +x "${bin}"
  mv "${bin}" "${dir}"
  echo "Installed ${bin} to ${dir}"
}

# Downloads kubectl binary to the current directory.
# kubectl needs special handling because:
# 1. dl.k8s.io has experienced 503 outages that outlast our retry window
# 2. Unlike other tools, kubectl binaries aren't available on GitHub releases
# 3. dl.k8s.io redirects to cdn.dl.k8s.io (Fastly), so we try the CDN directly as fallback
#
# Usage: download_kubectl_binary <version> <arch>
# Example: download_kubectl_binary "v1.28.0" "amd64"
# Downloads kubectl to ./kubectl in the current directory
download_kubectl_binary() {
  local version=$1
  local arch=$2

  echo "Downloading kubectl ${version} for ${arch}..."

  local kubectl_url="https://dl.k8s.io/release/${version}/bin/linux/${arch}/kubectl"
  local kubectl_cdn_url="https://cdn.dl.k8s.io/release/${version}/bin/linux/${arch}/kubectl"

  if ! curl_with_retry -LOs "${kubectl_url}"; then
    echo "Primary endpoint failed, trying CDN directly..."
    curl_with_retry -LOs "${kubectl_cdn_url}"
  fi

  chmod +x kubectl
}

# Downloads and extracts helm binary to the current directory.
# Usage: download_helm_binary <version> <arch>
# Example: download_helm_binary "v3.12.0" "amd64"
# Downloads and extracts helm to ./linux-<arch>/helm in the current directory
download_helm_binary() {
  local version=$1
  local arch=$2

  echo "Downloading helm ${version} for ${arch}..."

  local helm_url="https://get.helm.sh/helm-${version}-linux-${arch}.tar.gz"
  curl_with_retry -s -L "${helm_url}" -o helm.tar.gz
  tar -xf helm.tar.gz 2>/dev/null
  rm helm.tar.gz
}
