#!/usr/bin/env bash

set -Eeou pipefail

source scripts/evergreen/e2e/lib.sh

# This is the default cluster name to be used for single cluster. Multi-cluster variants need to override this.
export CLUSTER_NAME="kind-kind"
# In case of EVG tests, those variables need to be empty (in this case we assume an OpsManager test) or created by
# the setup_cloud_qa script. The latter case will create all credentials in $ENV_FILE. This case is handled below.
export OM_USER=""
export OM_API_KEY=""
export OM_ORGID=""
export OM_HOST=""
export OM_BASE_URL=""
# This file is used for injecting credentials when interacting with Cloud QA. Probably should be refactored
# into env vars in the future.
export ENV_FILE="${workdir:-}/.ops-manager-env"
if [ -f "${ENV_FILE}" ]; then
  source "${ENV_FILE}"
fi

export PROJECT_DIR="${script_dir:-}/../../../"

export NAMESPACE_FILE="${workdir}/.namespace"
if [ -f "${NAMESPACE_FILE}" ]; then
  echo "found existing namespace file"
  NAMESPACE=$(cat "${NAMESPACE_FILE}")
else
  echo "generating new namespace name"
  NAMESPACE=$(generate_random_namespace)
  echo "${NAMESPACE}" >"${NAMESPACE_FILE}"
fi
export NAMESPACE

export CLUSTER_TYPE="kind"
# Empty sting means that we're not using it.
export EVG_HOST_NAME=""
export GOROOT="/opt/golang/go1.24"

if [[ ! ${PATH} =~ .*${workdir:-.}/bin.* ]]; then
  export PATH=${PATH}:${workdir:-.}/bin
fi
if [[ ! ${PATH} =~ .*${GOROOT}/bin.* ]]; then
  export PATH=${GOROOT}/bin:${PATH}
fi

export LOCAL_OPERATOR="false"

export AWS_ACCESS_KEY_ID="${mms_eng_test_aws_access_key}"
export AWS_SECRET_ACCESS_KEY="${mms_eng_test_aws_secret}"
export AWS_DEFAULT_REGION="${mms_eng_test_aws_region}"

# setup_cloud_qa.py
export e2e_cloud_qa_orgid_owner="${e2e_cloud_qa_orgid_owner_ubi_cloudqa}"
export e2e_cloud_qa_apikey_owner="${e2e_cloud_qa_apikey_owner_ubi_cloudqa}"
export e2e_cloud_qa_user_owner="${e2e_cloud_qa_user_owner_ubi_cloudqa}"

export e2e_cloud_qa_baseurl="https://cloud-qa.mongodb.com"

export kubernetes_kind_version=1.22.0

# Note: this name is correct
export task_id="${EVR_TASK_ID}"

export OTEL_TRACE_ID="${otel_trace_id:-"0xdeadbeef"}"
export OTEL_COLLECTOR_ENDPOINT="${otel_collector_endpoint:-"unknown"}"

# This is given by an expansion from evg
export TASK_NAME="${task_name:-"unknown"}"
export task_name="${TASK_NAME}"
export IS_PATCH="${is_patch:-"unknown"}"
export BUILD_ID="${build_id:-"unknown"}"
export EXECUTION="${execution:-"unknown"}"
export BUILD_VARIANT="${build_variant:-"unknown"}"
export VERSION_ID="${version_id:-"unknown"}"
export GIT_TAG="${triggered_by_git_tag:-}"

# var used in pipeline.py to determine if we're running on EVG host
# used to discern between local pipeline image build and the build in pipeline
export RUNNING_IN_EVG="true"

export DELETE_KIND_NETWORK="true"

# code_snippets_commit_output can be set in evergreen patch by --param code_snippets_commit_output=true
# it's also set explicitly in public_*_snippets variants
export CODE_SNIPPETS_COMMIT_OUTPUT=${code_snippets_commit_output:-"false"}

# shellcheck disable=SC2154
export PRERELEASE_PULLSECRET_DOCKERCONFIGJSON="${community_private_preview_pullsecret_dockerconfigjson}"

export cognito_user_pool_id="${cognito_user_pool_id}"
export cognito_workload_federation_client_id="${cognito_workload_federation_client_id}"
export cognito_user_name="${cognito_user_name}"
export cognito_workload_federation_client_secret="${cognito_workload_federation_client_secret}"
export cognito_user_password="${cognito_user_password}"
export cognito_workload_url="${cognito_workload_url}"
export cognito_workload_user_id="${cognito_workload_user_id}"

export MDB_UPDATE_LICENSES=true

# Set BUILD_SCENARIO based on evergreen variables
# BUILD_SCENARIO can be overridden externally if needed
BUILD_SCENARIO_RELEASE="release" # Official release triggered by a git tag
BUILD_SCENARIO_STAGING="staging" # CI build from a merge to the master
BUILD_SCENARIO_PATCH="patch" # CI build for a patch/pull request
if [ -n "${BUILD_SCENARIO-}" ]; then
  echo "Build scenario has been set externally, not overriding it"
elif [ "${GIT_TAG}" ]; then
  BUILD_SCENARIO=$BUILD_SCENARIO_RELEASE
elif [ "${IS_PATCH}" == "true" ]; then
  BUILD_SCENARIO=$BUILD_SCENARIO_PATCH
else
  BUILD_SCENARIO=$BUILD_SCENARIO_STAGING
fi
echo "Setting BUILD_SCENARIO=${BUILD_SCENARIO}"
export BUILD_SCENARIO="${BUILD_SCENARIO}"

# Set REGISTRY and OPERATOR_VERSION, READINESS_PROBE_VERSION, VERSION_UPGRADE_HOOK_VERSION based on build scenario
# REGISTRY and OPERATOR_VERSION, READINESS_PROBE_VERSION, VERSION_UPGRADE_HOOK_VERSION can be overridden externally if needed
PATCH_REGISTRY="268558157000.dkr.ecr.us-east-1.amazonaws.com/dev"
STAGING_REGISTRY="268558157000.dkr.ecr.us-east-1.amazonaws.com/staging"
RELEASE_REGISTRY="quay.io/mongodb"
case $BUILD_SCENARIO in
  "${BUILD_SCENARIO_RELEASE}")
    REGISTRY="${REGISTRY:-$RELEASE_REGISTRY}"
    OPERATOR_VERSION="${OPERATOR_VERSION:-$GIT_TAG}"
    READINESS_PROBE_VERSION_FROM_RELEASE_JSON="$(jq -r '.readinessProbeVersion' "${PROJECT_DIR}/release.json")"
    READINESS_PROBE_VERSION="${READINESS_PROBE_VERSION:-$READINESS_PROBE_VERSION_FROM_RELEASE_JSON}"
    VERSION_UPGRADE_HOOK_VERSION_FROM_RELEASE_JSON="$(jq -r '.versionUpgradeHookVersion' "${PROJECT_DIR}/release.json")"
    VERSION_UPGRADE_HOOK_VERSION="${VERSION_UPGRADE_HOOK_VERSION:-$VERSION_UPGRADE_HOOK_VERSION_FROM_RELEASE_JSON}"
    ;;

  "${BUILD_SCENARIO_STAGING}")
    COMMIT_SHA_SHORT=$(git rev-parse --short=8 HEAD)
    REGISTRY="${REGISTRY:-$STAGING_REGISTRY}"
    OPERATOR_VERSION="${OPERATOR_VERSION:-$COMMIT_SHA_SHORT}"
    READINESS_PROBE_VERSION="${READINESS_PROBE_VERSION:-$COMMIT_SHA_SHORT}"
    VERSION_UPGRADE_HOOK_VERSION="${VERSION_UPGRADE_HOOK_VERSION:-$COMMIT_SHA_SHORT}"
    ;;

  "${BUILD_SCENARIO_PATCH}")
    REGISTRY="${REGISTRY:-$PATCH_REGISTRY}"
    OPERATOR_VERSION="${OPERATOR_VERSION:-$VERSION_ID}"
    READINESS_PROBE_VERSION="${READINESS_PROBE_VERSION:-$VERSION_ID}"
    VERSION_UPGRADE_HOOK_VERSION="${VERSION_UPGRADE_HOOK_VERSION:-$VERSION_ID}"
    ;;

  *)
    echo "Unknown BUILD_SCENARIO=${BUILD_SCENARIO}, exiting"
    exit 1
    ;;
esac
echo "Setting REGISTRY=${REGISTRY} and OPERATOR_VERSION=${OPERATOR_VERSION}, READINESS_PROBE_VERSION=${READINESS_PROBE_VERSION}, VERSION_UPGRADE_HOOK_VERSION=${VERSION_UPGRADE_HOOK_VERSION} for ${BUILD_SCENARIO} build scenario"
